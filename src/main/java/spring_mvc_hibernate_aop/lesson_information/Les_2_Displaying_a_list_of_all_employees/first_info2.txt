*** Les_2_Отображение списка всех работников ***

1. Начнем написание проекта с вывода всех работников из базы данных на экран.
С помощью браузера мы вводим определенный адрес (слэш "/"), который обрабатывается нашим контроллером.
В нашем контроллере будет срабатывать метод - showAllEmployees. Для вывода работников на экран мы
будем обращаться с помощью Hibernate к базе данных. Для этого в нашей архитектуре между контроллером
и базой данных мы поместим DAO (Employee DAO). DAO - Data Access Object. Именно этот DAO будет
разговаривать с БД с помощью Hibernate, обращаться к ней, получать всех работников и возвращать их
контроллеру. Далее мы помещаем информацию - список всех работников в модель и с помощью этой модели
наш view будет отображать информацию обо всех работниках.

2. В среде разработки создадим entity.
entity класс Employee нужен для того, чтобы связать класс Employee с таблицей employees_mvc.
entity класс создается с помощью аннотации @Entity и аннотации @Table.

3. Далее создадим пакет dao и в нем интерфейс EmployeeDAO пока с одним
методом public List<Employee> getAllEmployees ();

4. Далее в пакете dao создадим класс EmployeeDAOImpl который имплементирует интерфейс EmployeeDAO.
Для того чтобы EmployeeDAOImpl мог подключаться к базе данных посредством Hibernate, DAO должен иметь
доступ к sessionFactory. А bean sessionFactory мы создавали в applicationContext.xml, где он зависит
от бина dataSource. А в бине dataSource прописаны все параметры для подключения к БД.

Теперь нам нужно внедрить в EmployeeDAOImpl зависимость от sessionFactory бина. Это делается c
помощью создания поля private SessionFactory sessionFactory; и указания над ним аннотации @Autowired.
Здесь мы могли использовать разные виды Dependency Injection. Мы могли прописать это с помощью
конструктора, с помощью сеттера, а мы прописали Dependency Injection с помощью поля класса.
Теперь при запуске приложения будут созданы Бины - dataSource, sessionFactory, transactionManager
из applicationContext.xml и в EmployeeDAOImpl будет автоматически внедрена зависимость от
SessionFactory.

5. Далее напишем реализацию метода getAllEmployees в классе EmployeeDAOImpl.
При изучении Hibernate мы открывали транзакцию, выполняли какую-то работу с БД, закрывали
транзакцию с помощью commit. Здесь мы тоже можем так делать если хотим контролировать весь
жизненный цикл транзакции. Но так же теперь мы можем этого не делать указав аннотацию @Transactional
из пакета import org.springframework.transaction.annotation.Transactional; и доверить эту работу Spring-у.

6. Теперь пришла очередь создать Controller. Создадим пакет controller.
Далее создадим сам Controller - класс MyController. Пометим его аннотацией @Controller.
И в нашем контроллере MyController создаем метод showAllEmployees, который будет
возвращать view - all-employees.
Далее из нашего метода контроллера showAllEmployees, нам нужно вызвать метод getAllEmployees из
EmployeeDAOImpl. Чтобы вручную не создавать объект DAO - EmployeeDAOImpl, мы можем воспользоваться
Dependency Injection и создадим поле private EmployeeDAO employeeDAO; помеченное аннотацией @Autowired.

Чтобы view смог отобразить значение полей наших работников мы должны в методе контроллера showAllEmployees
создать модель и добавить наших работников в качестве атрибутов к нашей модели. Для этого в параметры
метода добавим модель и далее в теле метода добавим к этой модели атрибут, который будет
содержать лист наших работников. И теперь view будет использовать нашу модель, возьмет из
атрибута allEmps всю необходимую информацию для отображениz в браузере.

Создадим наш view all-employees.jsp и для отображения нашего списка работников будем использовать
jsp таблицу.

тег <tr> - строка таблицы
тег <th> - шапка(заголовок) таблицы
тег <td> - ячейка в таблице










